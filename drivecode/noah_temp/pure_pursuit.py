# -*- coding: utf-8 -*-
"""
Created on Wed Jun 19 18:33:49 2019

@author: Noah Michael Bamberger
"""
'''
This is a path following algorithm for a differential drive robot.

It uses an algorithm called pure pursuit, and is based off of the paper by
FRC team 1712 Dawgma. 
https://www.chiefdelphi.com/t/paper-implementation-of-the-adaptive-pure-pursuit
-controller/166552

The init requires a trajectory array data packet which is organized as follows:
[0]: [Time at index]
[1]: [Left velocity at index]
[2]: [Right velocity at index]
[3]: [Time step at index]
[4]: [x value of robot at index]
[5]: [y value of robot at index]
[6]: [Center velocity of robot at index]
[7]: [Boolean isBackwards variable]

This trajectory is generated by another tool, see my github for details

The controller function should be run in a while isFinished == False loop
which will pass in the encoder value change and the gyro heading value
'''

import math

class Pure_Pursuit():
    #create an instance of this class when you want to run the auton routine
    def __init__(self,trajectory,num_points,lookahead_distance,acceleration):
        #last_index is the index of the closest point to the robot
        self.last_index = 0
        
        self.trajectory = trajectory
        
        #num_points is the number of points in the path
        self.num_points = num_points
        
        #can be tuned to be shorter or longer, see docs for effects of tuning
        self.lookahead_distance = lookahead_distance
        
        #maximum acceleration before slipping
        self.acceleration = acceleration
        
        #distance from center of left wheels to center of right wheels
        self.trackwidth = 30
        
    #finds distance from robot to a point on the trajectory of index i
    def distance_to_point(self,i):
        robot_x = self.current_pos[0]
        robot_y = self.current_pos[1]
        point_x = self.trajectory[4][i]
        point_y = self.trajectory[5][i]
        
        #pythagorean formula
        distance = math.sqrt(math.pow((robot_x-point_x),2.0)+math.pow((robot_y-
                             point_y),2.0))
        return distance
    
    #finds distances to all points past last index searched in trajectory
    def find_closest_point(self):
        #initialize distances array
        distances = []
        
        #iterate through all points past last closest point, not going backward
        for i in range(self.last_index,self.num_points,1):
            distances.append(self.distance_to_point(i))
            
        #find index of point with minimum distance to robot
        self.last_index = distances.index(min(distances))
        
        #return array with all distances
        return distances
    
    #finds index of lookahead point
    def find_lookahead_point(self,distances):
        #initialize intersects array
        intersects = []
        
        #iterate through all distances to points from robot
        for i in range(0,self.num_points-self.last_index,1):
            
            #find how close to intersecting the lookahead circle the path is
            intersects.append(abs(self.lookahead_distance-distances[i]))
            
        #distance from bot at point that is closest to intersecting the path
        intersect_distance = min(intersects)
        
        #if the intersect_distance is too large, lookahead point is last point
        if intersect_distance > 2:
            return self.num_points
        else:
            return intersects.index(intersect_distance)
        
    #find curvature of driving arc
    def calc_arc_curvature(self,robot_heading,index):
        
        #lookahead point
        lookahead = self.trajectory[4][index]
        
        #intermediary values
        a = -math.tan(robot_heading)
        c=math.tan(robot_heading)*self.robot_location[0]-self.robot_location[1]
        d = math.sqrt(math.pow(a,2.0) + 1)
        x = abs(a*lookahead[0] + lookahead[1] + c)/d
        
        #return curvature of arc
        return 2*x/math.pow(self.lookahead_distance,2.0)
    
    #calculate velocity of center of robot
    def rate_limiter(self,index,robot_heading):
        #call curvature function
        curvature = self.calc_arc_curvature(robot_heading,index)
        
        #assuming that the arc isn't basically straight
        if curvature > .1:
            crv_lmtd_speed,radius,alpha = self.calc_target_velocity(
                    index,robot_heading,curvature)
            
        #if arc is nearly straight, curve doesn't limit velocity
        else:
            crv_lmtd_speed,radius,alpha = self.trajectory[5][self.last_index]
        limited_velocity = math.sqrt(math.pow(self.current_velocity,2.0)+
                          2*self.acceleration*self.step_size)
        
        return min(limited_velocity,crv_lmtd_speed),radius,alpha
    
    #calculate maximum target velocity from curvature
    def calc_target_velocity(self,index,robot_angle,curvature):
        #definition of curvature
        radius = 1/curvature
        
        #calculate the radius of the outer wheel path
        radius_outer_wheel = radius + (self.trackwidth/2)
        
        #maximum reachable angular velocity on that arc
        alpha = self.max_velocity/radius_outer_wheel
        
        #maximum reachable tangential velocity of center on that arc
        limited_velocity = alpha/radius
        if limited_velocity < self.trajectory[5][index]:
            return limited_velocity,radius,alpha
        else:
            alpha = self.trajectory[5][index]/radius_outer_wheel
            limited_velocity = alpha/radius
            return limited_velocity,radius,alpha
    def curvature_sign(self,lookahead_index,robot_heading):
        lookahead_point = self.trajectory[4][lookahead_index]
        x_dif = lookahead_point[0]-self.robot_location[0]
        y_dif = lookahead_point[1]-self.robot_location[1]
        cross_product = (math.sin(robot_heading)*x_dif - 
                         math.cos(robot_heading)*y_dif)
        sign = lambda cross_product: (cross_product>0) - (cross_product<0)
        return sign(cross_product)
    def offset_velocity(self,target_velocity,radius,alpha):
        if self.curvature_sign() == 1:
            left_velocity = alpha*(radius + (self.trackwidth/2))
            right_velocity = alpha*(radius - (self.trackwidth/2))
        else:
            left_velocity = alpha*(radius - (self.trackwidth/2))
            right_velocity = alpha*(radius + (self.trackwidth/2))
        return left_velocity,right_velocity
    def controller(self,x,y,robot_heading):
        self.robot_location = [x,y]
        distances = self.find_closest_point
        lookahead_index = self.find_lookahead_point(distances)
        target_velocity,radius,alpha = self.rate_limiter(lookahead_index,
                                                         robot_heading)
        left_velocity,right_velocity = self.offset_velocity(target_velocity
                                                            ,radius,alpha)
        if self.num_points - self.last_index < 10:
            isFinished = True
        return left_velocity,right_velocity,isFinished
        
        
        
    
